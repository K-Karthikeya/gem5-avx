//////////////////////////////////////////////////////////////////
// Minimal VEX two-byte opcode decodes for AVX subset.
//
// This file defines a distinct opcode state for VEX-encoded two-byte (0x0F)
// opcodes. Only a small AVX/AVX2 floating-point subset is implemented.

'X86ISA::TwoByteOpcodeVEX': decode OPCODE_OP {
    format Inst {
        // Arithmetic ops (reg-reg only, no memory form, no ModRM needed)
        0x58: decode VEX_L {
            0x1: VADDPS_YMM_YMM();
            0x0: VADDPS_XMM_XMM();
        }
        0x59: decode VEX_L {
            0x1: VMULPS_YMM_YMM();
            0x0: VMULPS_XMM_XMM();
        }
        0x57: decode VEX_L {
            0x1: VXORPS_YMM_YMM();
            0x0: VXORPS_XMM_XMM();
        }
        // Load from memory (M operand triggers doModRM via specializeInst)
        0x10: decode VEX_L {
            0x1: VMOVUPS_YMM(M);
            0x0: VMOVUPS_XMM(M);
        }
        // Store to memory (M operand triggers doModRM via specializeInst)
        0x11: decode VEX_L {
            0x1: VMOVUPS_M_YMM(M);
            0x0: VMOVUPS_M_XMM(M);
        }
        0x28: decode VEX_L {
            0x1: VMOVAPS_YMM(M);
            0x0: VMOVAPS_XMM(M);
        }
        0x29: decode VEX_L {
            0x1: VMOVAPS_M_YMM(M);
            0x0: VMOVAPS_M_XMM(M);
        }
        0x77: VZEROUPPER();
        default: UD2();
    }
}